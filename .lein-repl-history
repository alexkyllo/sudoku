(coord-pairs 0 1)
(require sudoku)
(:require sudoku)
(use 'sudoku)
(coord-pairs 0 1)
(coord-pairs [0 1])
(coord-pairs [0 1 2])
(coord-pairs [0 1 2 3])
(use 'sudoku)
(coord-pairs [0 1 2 3])
(use 'sudoku)
(coord-pairs [0 1 2])
(require 'sudoku)
(coord-pairs [0 1 2])
(use 'sudoku)
(coord-pairs [0 1 2])
(let [min-block (fn [x] (cond (< x 3) 0 (< x 6) 3 :else 6))])
(min-block 2)
(defn min-block [x] (cond (< x 3) 0 (< x 6) 3 :else 6))
(min-block 2)
(min-block 3)
(min-block 5)
(map min-block [4 3])
(map min-block [4 4])
(map min-block [0 4])
(map min-block [0 1])
(range 3 6)
(use 'sudoku)
(block-values example-board [1 1])
(use 'sudoku)
(valid-values-for example-board [0 0])
(valid-values-for example-board [0 2])
(use 'sudoku :reload)
(valid-values-for example-board [0 2])
(valid-values-for example-board [0 0])
(use 'sudoku :reload)
(valid-values-for example-board [0 0])
(use 'sudoku :reload)
(valid-values-for example-board [0 0])
(valid-values-for example-board [0 2])
(doc set/difference)
(doc clojure.set/difference)
(use 'sudoku :reload)
(valid-values-for example-board [0 2])
(use 'sudoku :reload)
(use 'midje.repl)
(autotest)
(use 'sudoku)
(use 'midje/repl)
(use 'midje.repl)
(autotest)
st)
(autotest)
(load-facts)
(autotest)
(check-facts)
(val '(3 2 4 1 5 6 7 8 9))
(valid-row? '(3 2 4 1 5 6 7 8 9))
(use 'sudoku :reload)
(valid-row? '(3 2 4 1 5 6 7 8 9))
(valid-row? '(3 2 4 1 5 6 7 8 8))
(use 'sudoku :reload)
(valid-row? '(3 2 4 1 5 6 7 8 8))
(valid-row? '(3 2 4 1 5 6 7 8 9))
(valid-row? [3 2 4 1 5 6 7 8 9])
(valid-row? [3 2 4 1 5 6 7 0 9])
(check-facts)
(for [row [0 1 2] col [0 1 2]])
(for [row [0 1 2] col [0 1 2]] [row col])
